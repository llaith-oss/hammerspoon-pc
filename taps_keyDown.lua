
-- -------------------------------------------------------------------------------------
-- Trap keyDown
-- -------------------------------------------------------------------------------------
etKeyDown = hs.eventtap.new({hs.eventtap.event.types.keyDown}, function (e)
  local cancel = false

  local kc = e:getKeyCode() -- Key user pressed
  local flags = hs.eventtap.checkKeyboardModifiers() -- Modifier keys user was pressing
  local data = e:getProperty(EVENTPROPERTY_EVENTSOURCEUSERDATA)

  log('keyDown event: keycode=' .. tostring(kc) .. '; userdata=' .. tostring(data) .. '; semaphore=' ..  tostring(semaphore) .. '; flags=' .. hs.inspect(e:getFlags()))

  -- Only do if not an event generated by another script (which sets
  -- the userdata of the event to distinguish itself from user/OS key events)
  -- See getKeyEvent()
  if data ~= 55555 then

    -- -------------------------------------------
    -- NO MODIFIER STROKES/COMBOS
    -- -------------------------------------------
    if not flags.ctrl and not flags.shift and not flags.alt and not flags.cmd then

      if kc == 96  then return keyEvents.ctrlR()  end -- F5 = reload
      if kc == 115 then return keyEvents.home()   end -- home key
      if kc == 119 then return keyEvents.endKey() end -- end key

    end

    -- -------------------------------------------
    -- CTRL COMBOS
    -- -------------------------------------------
    if flags.ctrl then

      if semaphore == 1 then
        log('Semaphore set. Skipping event for keycode ' .. tostring(e:getKeyCode()))
        return true
      end

      if kc == 0  then return keyEvents.ctrlA() end -- A = select all
      if kc == 1  then return keyEvents.ctrlS() end -- S = save
      if kc == 3  then return keyEvents.find()  end -- S = save
      if kc == 6  then return keyEvents.ctrlZ() end -- Z = undo
      if kc == 7  then return keyEvents.ctrlX() end -- X = cut
      if kc == 8  then return keyEvents.ctrlC() end -- C = copy
      if kc == 9  then return keyEvents.ctrlP() end -- V = paste
      if kc == 11 then return keyEvents.ctrlB() end -- B = bold
      if kc == 13 then return keyEvents.ctrlW() end -- W = close
      if kc == 15 then return keyEvents.ctrlR() end -- R = reload
      if kc == 16 then return keyEvents.ctrlY() end -- Y = redo
      if kc == 32 then return keyEvents.ctrlU() end -- U = underline
      if kc == 34 then return keyEvents.ctrlI() end -- I = italics

      -- If ctrl+home pressed, strip off ctrl and send home. Flip what mac does with what pc does)
      if kc == 115 then -- Home = home (strip ctrl flag)
        if flags.shift then
          return keyEvents.ctrlShiftHome() -- Pass through keycode sans modifiers for mac context
        else
          return keyEvents.ctrlHome()
        end
      end

      if kc == 119 then -- End = end (strip ctrl flag)
        if flags.shift then
          return keyEvents.ctrlShiftEnd() -- Pass through keycode sans modifiers for mac context
        else
          return keyEvents.ctrlEnd()
        end
      end
      -- Warning: Overrides control+arrows for navigating desktops
      -- This doesn't quite work right yet. It doesn't support reapeat. If you repeat too fast
      -- the OS will get the event and you will switch desktops if you have multiple open. Sigh.
      -- This is an attempt to map control+arrows to option+arrows to "select to beginning
      -- of next word" like on a PC.
      -- Running into issues with rapid repeat (and auto repeat for that matter). The
      -- sequencing is tricky. Will probably take a queue mechanism to store all repeats for
      -- sequential playback, with shunting of other mapping operations and cancelling events
      -- at the OS level to make it all work. Very tricky business. Sigh.
      if kc == 124 then -- right arrow
        if flags.shift then
          --log('Ctrl Shift Left arrow')
          return keyEvents.ctrlShiftLeft()
        else
          --log('Ctrl Left arrow')
          return keyEvents.ctrlLeft()
        end
      end
      if kc == 123 then -- right arrow
        if flags.shift then
          --log('Ctrl Shift Right arrow')
          return keyEvents.ctrlShiftRight()
        else
          --log('Ctrl Right arrow')
          return keyEvents.ctrlRight()
        end
      end

    else
      -- -------------------------------------------
      -- SHIFT COMBOS
      -- -------------------------------------------
      if flags.shift then
        -- If ctrl+home|end pressed, strip off ctrl and send home|end Flip what mac does with what pc does)
        if kc == 115 then return keyEvents.shiftHome() end -- Home = home (strip ctrl flag)
        if kc == 117 then keyEvents.shiftFwdDelete() return true end -- forwarddelete = cut
        if kc == 119 then return keyEvents.shiftEnd() end -- End = end (strip ctrl flag)
      end
    end -- if flags.ctrl then
  end -- if data ~= 55555 then
  -- Cancel event or app will do what a normal key press doesfff
  return cancel

end)
etKeyDown:start()

-- -------------------------------------------------------------------------------------
-- Cancel any other keyboard events while another binding action (script) is working
ekKeyDownShuntCtrl = hs.eventtap.new({hs.eventtap.event.types.keyDown}, function (e)
  --print('keyDown (shunt) event userdata=' .. tostring(e:getProperty(EVENTPROPERTY_EVENTSOURCEUSERDATA)) .. "; Semaphore=" ..  tostring(semaphore))
  if e:getFlags().ctrl == true
      and e:getProperty(EVENTPROPERTY_EVENTSOURCEUSERDATA) < 55555
      and semaphore == 1 then
    print('Shunting ctrl event')
    return true
  end
end)
